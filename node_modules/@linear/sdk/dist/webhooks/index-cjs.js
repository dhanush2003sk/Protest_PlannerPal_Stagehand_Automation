'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var crypto = require('crypto');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto);

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

const LINEAR_WEBHOOK_SIGNATURE_HEADER = "linear-signature";
const LINEAR_WEBHOOK_TS_FIELD = "webhookTimestamp";
/**
 * Client for handling Linear webhook requests with helpers.
 */
class LinearWebhookClient {
    /**
     * Creates a new LinearWebhookClient instance
     * @param secret The webhook signing secret. See https://linear.app/developers/webhooks#securing-webhooks.
     */
    constructor(secret) {
        this.secret = secret;
    }
    /**
     * Creates a webhook handler function that can process Linear webhook requests
     * @returns A webhook handler function with event registration capabilities.
     * Supports both Fetch API `(request: Request) => Promise<Response>` and
     * Node.js `(request: IncomingMessage, response: ServerResponse) => Promise<void>`
     */
    createHandler() {
        const eventHandlers = new Map();
        const handler = (requestOrMessage, response) => __awaiter(this, void 0, void 0, function* () {
            const adapter = this.getHttpAdapter(requestOrMessage, response);
            try {
                if (adapter.method !== "POST") {
                    return adapter.send(405, "Method not allowed");
                }
                const signature = adapter.signature;
                if (!signature) {
                    return adapter.send(400, "Missing webhook signature");
                }
                const rawBody = yield adapter.readRawBody();
                let parsedPayload;
                try {
                    parsedPayload = this.parseVerifiedPayload(rawBody, signature);
                }
                catch (_a) {
                    return adapter.send(400, "Invalid webhook");
                }
                const allHandlers = this.collectHandlers(eventHandlers, parsedPayload.type);
                yield Promise.all(allHandlers.map(h => h(parsedPayload)));
                return adapter.send(200, "OK");
            }
            catch (_b) {
                return adapter.send(500, "Internal server error");
            }
        });
        handler.on = function (eventType, eventHandler) {
            const handlers = eventHandlers.get(eventType) || [];
            handlers.push(eventHandler);
            eventHandlers.set(eventType, handlers);
        };
        handler.off = function (eventType, eventHandler) {
            const handlers = eventHandlers.get(eventType);
            if (handlers) {
                const index = handlers.indexOf(eventHandler);
                if (index > -1) {
                    handlers.splice(index, 1);
                    if (handlers.length === 0) {
                        eventHandlers.delete(eventType);
                    }
                }
            }
        };
        handler.removeAllListeners = function (eventType) {
            if (eventType) {
                eventHandlers.delete(eventType);
            }
            else {
                eventHandlers.clear();
            }
        };
        return handler;
    }
    /**
     * Determines whether the provided value is a Fetch API `Request`.
     * Used as a type guard to select the appropriate runtime path.
     *
     * @param value - Unknown request-like value
     * @returns True if `value` is a Fetch API `Request`
     */
    isFetchRequest(value) {
        return (typeof value === "object" &&
            value !== null &&
            "arrayBuffer" in value &&
            typeof Reflect.get(value, "arrayBuffer") === "function");
    }
    /**
     * Creates an HTTP adapter for Fetch-based runtimes.
     * The body is not read until `readRawBody` is invoked.
     *
     * @param request - Fetch API `Request`
     * @returns Helpers to read input and send responses in a unified way
     */
    createFetchAdapter(request) {
        return {
            method: request.method,
            signature: request.headers.get(LINEAR_WEBHOOK_SIGNATURE_HEADER),
            readRawBody: () => __awaiter(this, void 0, void 0, function* () { return Buffer.from(yield request.arrayBuffer()); }),
            send: (status, body) => new Response(body, { status }),
        };
    }
    /**
     * Creates an HTTP adapter for Node.js HTTP runtimes.
     * The body stream is consumed when `readRawBody` is invoked.
     *
     * @param incomingMessage - Node.js `IncomingMessage`
     * @param res - Node.js `ServerResponse` used to write the response
     * @returns Helpers to read input and send responses in a unified way
     */
    createNodeAdapter(incomingMessage, res) {
        var _a;
        const headerValue = incomingMessage.headers[LINEAR_WEBHOOK_SIGNATURE_HEADER];
        const signature = Array.isArray(headerValue) ? ((_a = headerValue[0]) !== null && _a !== void 0 ? _a : null) : (headerValue !== null && headerValue !== void 0 ? headerValue : null);
        return {
            method: incomingMessage.method || "",
            signature,
            readRawBody: () => __awaiter(this, void 0, void 0, function* () {
                var e_1, _b;
                const chunks = [];
                try {
                    for (var incomingMessage_1 = __asyncValues(incomingMessage), incomingMessage_1_1; incomingMessage_1_1 = yield incomingMessage_1.next(), !incomingMessage_1_1.done;) {
                        const chunk = incomingMessage_1_1.value;
                        chunks.push(Buffer.from(chunk));
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (incomingMessage_1_1 && !incomingMessage_1_1.done && (_b = incomingMessage_1.return)) yield _b.call(incomingMessage_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return Buffer.concat(chunks);
            }),
            send: (status, body) => {
                res.statusCode = status;
                res.end(body);
            },
        };
    }
    /**
     * Selects and constructs the appropriate HTTP adapter for the
     * provided request type (Fetch or Node.js HTTP).
     *
     * @param requestOrMessage - A Fetch `Request` or Node.js `IncomingMessage`
     * @param response - Node.js `ServerResponse` (required for Node path)
     * @returns An HTTP adapter with unified IO helpers
     */
    getHttpAdapter(requestOrMessage, response) {
        return this.isFetchRequest(requestOrMessage)
            ? this.createFetchAdapter(requestOrMessage)
            : this.createNodeAdapter(requestOrMessage, response);
    }
    /**
     * Parses the JSON body and verifies signature and optional timestamp.
     *
     * Throws if the JSON is invalid, the signature is invalid, or the timestamp check fails.
     *
     * @param rawBody - Raw request body as a Buffer
     * @param signature - The value of the `linear-signature` header
     * @returns The verified and parsed webhook payload
     */
    parseVerifiedPayload(rawBody, signature) {
        const parsedBody = this.parseBodyAsWebhookPayload(rawBody);
        const verified = this.verify(rawBody, signature, parsedBody.webhookTimestamp);
        if (!verified) {
            throw new Error("Invalid webhook signature");
        }
        return parsedBody;
    }
    /**
     * Parses the raw body as a webhook payload with typing.
     *
     * @param rawBody - Raw request body as a Buffer
     * @returns Parsed webhook payload object
     */
    parseBodyAsWebhookPayload(rawBody) {
        return JSON.parse(rawBody.toString());
    }
    /**
     * Returns the list of handlers to invoke for a given event type,
     * including both specific and wildcard handlers.
     *
     * @param eventHandlers - Internal registry of event handlers
     * @param eventType - The webhook `type` field from the payload
     * @returns Ordered list of handlers to be executed
     */
    collectHandlers(eventHandlers, eventType) {
        const specificHandlers = eventHandlers.get(eventType) || [];
        const wildcardHandlers = eventHandlers.get("*") || [];
        return [...specificHandlers, ...wildcardHandlers];
    }
    /**
     * Verify the webhook signature
     *
     * Throws an error if the signature or timestamp is invalid.
     *
     * @param rawBody The webhook request raw body
     * @param signature The signature to verify
     * @param timestamp The `webhookTimestamp` field from the request parsed body
     * @returns True if the signature is valid
     */
    verify(rawBody, signature, timestamp) {
        const verificationBuffer = Buffer.from(crypto__default["default"].createHmac("sha256", this.secret).update(rawBody).digest("hex"));
        const signatureBuffer = Buffer.from(signature);
        if (verificationBuffer.length !== signatureBuffer.length) {
            throw new Error("Invalid webhook signature");
        }
        if (!crypto__default["default"].timingSafeEqual(verificationBuffer, signatureBuffer)) {
            throw new Error("Invalid webhook signature");
        }
        if (timestamp) {
            const timeDiff = Math.abs(new Date().getTime() - timestamp);
            // Throw error if more than one minute delta between provided ts and current time
            if (timeDiff > 1000 * 60) {
                throw new Error("Invalid webhook timestamp");
            }
        }
        return true;
    }
    /**
     * Parse and verify webhook data, throwing an error if the signature or given timestamp is invalid.
     *
     * @param rawBody The webhook request raw body
     * @param signature The signature to verify
     * @param timestamp The `webhookTimestamp` field from the request parsed body
     */
    parseData(rawBody, signature, timestamp) {
        const verified = this.verify(rawBody, signature, timestamp);
        if (!verified) {
            throw new Error("Invalid webhook signature");
        }
        return this.parseBodyAsWebhookPayload(rawBody);
    }
}

exports.LINEAR_WEBHOOK_SIGNATURE_HEADER = LINEAR_WEBHOOK_SIGNATURE_HEADER;
exports.LINEAR_WEBHOOK_TS_FIELD = LINEAR_WEBHOOK_TS_FIELD;
exports.LinearWebhookClient = LinearWebhookClient;
//# sourceMappingURL=index-cjs.js.map
